# WaveformDataArrayBufferAdapter

<table>
  <tr>
    <th><code>response_data</code></th>
    <td><code>DataView</code></td>
    <td></td>
  </tr>
</table>

* See: `WaveformDataArrayBufferAdapter.fromResponseData`
* `@constructor`


> ArrayBuffer adapter consumes binary waveform data (data format version 1).
It is used as a data abstraction layer by `WaveformData`.

This is supposed to be the fastest adapter ever:
* **Pros**: working directly in memory, everything is done by reference (including the offsetting)
* **Cons**: binary data are hardly readable without data format knowledge (and this is why this adapter exists).

Also, it is recommended to use the `fromResponseData` factory.

# WaveformDataArrayBufferAdapter.isCompatible()

<table>
  <tr>
    <th><code>data</code></th>
    <td><code>Mixed</code></td>
    <td></td>
  </tr>
</table>

* `@static`
* `@returns`


> Detects if a set of data is suitable for the ArrayBuffer adapter.
It is used internally by `WaveformData.create` so you should not bother using it.

# WaveformDataArrayBufferAdapter.fromResponseData()

<table>
  <tr>
    <th><code>response_data</code></th>
    <td><code>ArrayBuffer</code></td>
    <td></td>
  </tr>
</table>

* `@static`
* `@return` `WaveformDataArrayBufferAdapter` 


> Setup factory to create an adapter based on heterogeneous input formats.

It is the preferred way to build an adapter instance.

```javascript
var arrayBufferAdapter = WaveformData.adapters.arraybuffer;
var xhr = new XMLHttpRequest();

// .dat file generated by audiowaveform program
xhr.open("GET", "http://example.com/waveforms/track.dat");
xhr.responseType = "arraybuffer";
xhr.addEventListener("load", function onResponse(progressEvent){
 var responseData = progressEvent.target.response;

 // doing stuff with the raw data ...
 // you only have access to WaveformDataArrayBufferAdapter API
 var adapter = arrayBufferAdapter.fromResponseData(responseData);

 // or making things easy by using WaveformData ...
 // you have access WaveformData API
 var waveform = new WaveformData(responseData, arrayBufferAdapter);
});

xhr.send();
```

# WaveformDataArrayBufferAdapter.prototype.version


* `@return` `Integer` Version number of the consumed data format.


> Returns the data format version number.

# WaveformDataArrayBufferAdapter.prototype.is_8_bit


* `@return` `boolean` True if data are declared to be 8bits encoded.


> Indicates if the response body is encoded in 8bits.

**Notice**: currently the adapter only deals with 8bits encoded data.
You should favor that too because of the smaller data network fingerprint.

# WaveformDataArrayBufferAdapter.prototype.is_16_bit


* `@return` `boolean` True if data are declared to be 16bits encoded.


> Indicates if the response body is encoded in 16bits.

# WaveformDataArrayBufferAdapter.prototype.sample_rate


* `@return` `Integer` Number of samples per second.


> Returns the number of samples per second.

# WaveformDataArrayBufferAdapter.prototype.scale


* `@return` `Integer` Number of samples per pixel.


> Returns the scale (number of samples per pixel).

# WaveformDataArrayBufferAdapter.prototype.length


* `@return` `Integer` Length of the waveform data.


> Returns the length of the waveform data (number of data points).

# WaveformDataArrayBufferAdapter.prototype.at()

<table>
  <tr>
    <th><code>index</code></th>
    <td><code>Integer</code></td>
    <td></td>
  </tr>
</table>

* `@return` `number` waveform value


> Returns a value at a specific offset.

